#!/usr/bin/python

# Copyright (C) 2010 Javier Palacios
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License Version 2
# as published by the Free Software Foundation.
# 
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.


import amebaC3_client.client


import ConfigParser

configfile = "/etc/aupd.conf"

config = ConfigParser.RawConfigParser()
config.read( configfile )

import sys

usage = """
\t%prog [--autogenerate] [--distro distroname] register [url [uuid] ]
\t%prog [--check-interval seconds] [--random-wait seconds] pulldaemon
\t%prog pull
\t%prog login
\t%prog --sessid id logout
\t%prog loginout
"""

version = "%prog 1.1"


import os , glob

def guess_distro ( ) :

    # FIXME : create the first parser with this code !!!
    if os.path.isfile( "/etc/lsb-release" ) :
        fd = open( "/etc/lsb-release" )
        for line in fd.readlines() :
            k,v = line[:-1].split('=',1)
            if k == "DISTRIB_CODENAME" :
                fd.close()
                return v
        fd.close()

    # FIXME : returning distro name is not enough, create specific parsers and return nothing if not implemented
    for file in glob.glob( "/etc/*-release" ) :
        return os.path.basename( file[:-8] )
    # NOTE : en suse hay un /etc/SuSE-brand que es lo que necesitamos

    if os.path.isfile( "/etc/debian_version" ) :
        fd = open( "/etc/debian_version" )
        v = fd.readline()[:-1]
        fd.close()
        return v


import uuid
import socket

def register ( config , options , args ) :

    update_config = False

    _url = None

    if args :
        _url = args.pop(0)
        update_config = True

    if config.has_option( 'registration' , 'url' ) :
        if _url :
            print "ERROR : server URL already given on configuration file"
            sys.exit(1)
        _url = config.get( 'registration' , 'url' )

    _uuid = None

    if args :
        _uuid = args.pop(0)
        update_config = True

    if _uuid and options.autouuid :
        print "ERROR : You should not give explicit UUID when requesting autogeneration"
        sys.exit(1)

    if options.autouuid :
        _uuid = uuid.uuid4()

    if config.has_option( 'registration' , 'uuid' ) :
        if _uuid :
            print "ERROR : UUID already given on configuration file"
            sys.exit(1)
        _uuid = config.get( 'registration' , 'uuid' )

    _distro = guess_distro()
    if options.distro :
        _distro = options.distro

    if not _url or not _uuid  or not _distro:
        print "ERROR : Missing parameters"
        parser.print_help()
        sys.exit(1)

    if args :
        print "ERROR : too many arguments"
        parser.print_help()
        sys.exit(1)

    data = { 'UUID':_uuid , 'HOSTNAME':socket.gethostname() , 'DISTRO':_distro }
    if amebaC3_client.client.register( _url , data ) :
        if amebaC3_client.client.has_errmsg() :
            for msg in amebaC3_client.client.get_all_errmsg() :
                print "WARNING : %s" % msg
        if update_config :
            if not config.has_section( 'registration' ) :
                config.add_section( 'registration' )
            config.set( 'registration' , 'url' , _url )
            config.set( 'registration' , 'uuid' , _uuid )
#FIXME : Verify user/permissions before writing config, or even calling urlopen
            fd = open( configfile , 'w' )
            config.write( fd )
            fd.close()
    else :
        for msg in amebaC3_client.client.get_all_errmsg() :
            print "ERROR : %s" % msg


def login ( config , options , args ) :

    if args :
        parser.print_help()
        sys.exit(1)

    _url = config.get( 'registration' , 'url' )
    _uuid = config.get( 'registration' , 'uuid' )

    sessid , delay = amebaC3_client.client.login ( _url , _uuid )
    if sessid :
        print "session id : %s" % sessid
        if delay :
            print "activated in %s seconds" % delay
        if amebaC3_client.client.has_errmsg() :
            for msg in amebaC3_client.client.get_all_errmsg() :
                print "WARNING : %s" % msg
    else :
        for msg in amebaC3_client.client.get_all_errmsg() :
            print "ERROR : %s" % msg


def logout ( config , options , args ) :

    if not options.sessid :
        print "ERROR : Missing parameters"
        parser.print_help()
        sys.exit(1)

    if args :
        parser.print_help()
        sys.exit(1)

    _url = config.get( 'registration' , 'url' )

    if amebaC3_client.client.logout ( _url , options.sessid ) :
        print "session closed : %s" % options.sessid
        if amebaC3_client.client.has_errmsg() :
            for msg in amebaC3_client.client.get_all_errmsg() :
                print "WARNING : %s" % msg
    else :
        for msg in amebaC3_client.client.get_all_errmsg() :
            print "ERROR : %s" % msg


def pull ( config , options , args ) :

    process_msgs = True
    if args and args[0] == "buffermsgs" :
        args.pop(0)
        process_msgs = False

    if args :
        parser.print_help()
        sys.exit(1)

    _url = config.get( 'registration' , 'url' )
    _uuid = config.get( 'registration' , 'uuid' )

    if not config.has_section( 'pull' ) :
        print "ERROR : pull section mising on configuration"
        sys.exit(1)

    if not config.has_option( 'pull' , 'commands' ) :
        print "ERROR : No commands defined on pull section"
        sys.exit(1)

    _cmds = config.get( 'pull' , 'commands' )

    ret = amebaC3_client.client.pull ( _url , _uuid , _cmds.split(',') )
    if ret :
        if process_msgs :
            if amebaC3_client.client.has_errmsg() :
                for msg in amebaC3_client.client.get_all_errmsg() :
                    print "WARNING : %s" % msg
    else :
        if process_msgs :
            for msg in amebaC3_client.client.get_all_errmsg() :
                print "ERROR : %s" % msg

    return ret


def loginout ( config , options , args ) :

    if args :
        parser.print_help()
        sys.exit(1)

    _url = config.get( 'registration' , 'url' )
    _uuid = config.get( 'registration' , 'uuid' )

    if amebaC3_client.client.loginout ( _url , _uuid ) :
        if amebaC3_client.client.has_errmsg() :
            for msg in amebaC3_client.client.get_all_errmsg() :
                print "WARNING : %s" % msg
    else :
        for msg in amebaC3_client.client.get_all_errmsg() :
            print "ERROR : %s" % msg


import random

import threading

timerid = None

def __pulldaemon ( config , options , args , check_interval , random_wait ) :

    ret = pull( config , options , list(args) )
    if ret :
        # NOTE : we just drop any warnings
        amebaC3_client.client.get_all_errmsg()
    else :
        # NOTE : error reporting cannot be done via stdout
        amebaC3_client.client.get_all_errmsg()
        #for msg in amebaC3_client.client.get_all_errmsg() :
        #    print "ERROR : %s" % msg
    timerid = threading.Timer( check_interval + random_wait * random.random() , __pulldaemon , ( config , options , args , check_interval , random_wait ) )
    timerid.start()

import amebaC3_client.daemon

def pulldaemon ( config , options , args ) :

    check_interval = False

    if config.has_option( 'pulldaemon' , 'check-interval' ) :
        check_interval = config.getfloat( 'pulldaemon' , 'check-interval' )

    if options.interval :
        check_interval = float(options.interval)

    if check_interval is False :
        print "ERROR : Missing parameters"
        parser.print_help()
        sys.exit(1)

    random_wait = 0

    if config.has_option( 'pulldaemon' , 'random-wait' ) :
        check_interval = config.getfloat( 'pulldaemon' , 'random-wait' )

    if options.wait :
        random_waitval = float(options.wait)

    if args :
        parser.print_help()
        sys.exit(1)

    retcode = amebaC3_client.daemon.createDaemon()

    args.append( "buffermsgs" )
    # NOTE : we create a timer instead of calling __pulldaemon to delay the initial pull
    timerid = threading.Timer( check_interval + random_wait * random.random() , __pulldaemon , ( config , options , args , check_interval , random_wait ) )
    timerid.start()


command = { 'register':register ,
            'pull':pull ,
            'logout':logout ,
            'login':login ,
            'loginout':loginout ,
            'pulldaemon':pulldaemon ,
            }

import optparse

parser = optparse.OptionParser(usage=usage, version=version)
parser.set_defaults( autouuid=False )

parser.add_option("--autogenerate",
        action="store_true", dest="autouuid",
        help="Automatically generate a random UUID")

parser.add_option("--distro", dest="distro",
        help="Set primary channel")

parser.add_option("--sessid", dest="sessid",
        help="Set session ID")

# FIXME : force value to float number, and remove coercion in call to time.sleep
parser.add_option("--check-interval", dest="interval",
        help="Set time interval in seconds within checks")

parser.add_option("--random-wait", dest="wait",
        help="Set maximum random waiting time")

options , args = parser.parse_args()

if not args :
    parser.print_help()
    sys.exit(1)

subcmd = args.pop(0)

if not command.has_key( subcmd ) :
    parser.print_help()
    sys.exit(1)

command[ subcmd ]( config , options , args )

