#!/usr/bin/python

# Copyright (C) 2010 Javier Palacios
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License Version 2
# as published by the Free Software Foundation.
# 
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.

import ConfigParser

configfile = "/etc/aupd.conf"

config = ConfigParser.RawConfigParser()
config.read( configfile )

import optparse

import urllib , urllib2
import socket

import subprocess
import sys , time

usage = """
\t%prog [--autogenerate] [--distro distroname] register [url [uuid] ]
\t%prog pull
\t%prog login
\t%prog --sessid id logout
\t%prog loginout
"""

version = "%prog 0.9"

import os , glob

def guess_distro ( ) :

    # FIXME : create the first parser with this code !!!
    if os.path.isfile( "/etc/lsb-release" ) :
        fd = open( "/etc/lsb-release" )
        for line in fd.readlines() :
            k,v = line[:-1].split('=',1)
            if k == "DISTRIB_CODENAME" :
                fd.close()
                return v
        fd.close()

    # FIXME : returning distro name is not enough, create specific parsers and return nothing if not implemented
    for file in glob.glob( "/etc/*-release" ) :
        return os.path.basename( file[:-8] )
    # NOTE : en suse hay un /etc/SuSE-brand que es lo que necesitamos

    if os.path.isfile( "/etc/debian_version" ) :
        fd = open( "/etc/debian_version" )
        v = fd.readline()[:-1]
        fd.close()
        return v

import uuid

def register ( config , options , args ) :

    update_config = False

    _url = None

    if args :
        _url = args.pop(0)
        update_config = True

    if config.has_option( 'registration' , 'url' ) :
        if _url :
            print "ERROR : server URL already given on configuration file"
            sys.exit(1)
        _url = config.get( 'registration' , 'url' )

    _uuid = None

    if args :
        _uuid = args.pop(0)
        update_config = True

    if _uuid and options.autouuid :
        print "ERROR : You should not give explicit UUID when requesting autogeneration"
        sys.exit(1)

    if options.autouuid :
        _uuid = uuid.uuid4()

    if config.has_option( 'registration' , 'uuid' ) :
        if _uuid :
            print "ERROR : UUID already given on configuration file"
            sys.exit(1)
        _uuid = config.get( 'registration' , 'uuid' )

    _distro = guess_distro()
    if options.distro :
        _distro = options.distro

    if not _url or not _uuid  or not _distro:
        print "ERROR : Missing parameters"
        parser.print_help()
        sys.exit(1)

    if args :
        print "ERROR : too many arguments"
        parser.print_help()
        sys.exit(1)

    data = { 'UUID':_uuid , 'HOSTNAME':socket.gethostname() , 'DISTRO':_distro }
    return __register( _url , data )

def __register ( url , data ) :

    try :
        res = urllib2.urlopen( "%s/register" % url , urllib.urlencode( data ) )
    except urllib2.HTTPError , res :
        print "ERROR : %s" % res.msg
        print "".join( res.readlines() )
    else :
        firstline = res.readline()
        if firstline != "OK" :
            print "WARNING : %s" % firstline
            for line in res.readlines() :
                print line[:-1]
        else :
            if update_config :
                if not config.has_section( 'registration' ) :
                    config.add_section( 'registration' )
                config.set( 'registration' , 'url' , url )
                config.set( 'registration' , 'uuid' , data['UUID'] )
#FIXME : Verify user/permissions before writing config, or even calling urlopen
                fd = open( configfile , 'w' )
                config.write( fd )
                fd.close()


def login ( config , options , args ) :

    if args :
        parser.print_help()
        sys.exit(1)

    _url = config.get( 'registration' , 'url' )
    _uuid = config.get( 'registration' , 'uuid' )

    sessid , delay = __login ( _url , _uuid )
    if sessid :
        print "session id : %s" % sessid
        if delay :
            print "activated in %s seconds" % delay

def __login ( url , uuid ) :

    req = urllib2.Request( "%s/login" % url )
    req.add_header( "Authorization" , "UUID %s" % uuid )

    sessid , delay = None , 0

    try :
        res = urllib2.urlopen( req )
    except urllib2.HTTPError , res :
        print "ERROR : %s" % res.msg
        print "".join( res.readlines() )
    else :
        firstline = res.readline()
        if not firstline.startswith( "ID " ) :
            print "WARNING : %s" % firstline
            for line in res.readlines() :
                print line[:-1]
        else :
            sessid = firstline.split(None,1)[1]
        delay = float( res.headers.get( 'X-AmebaDelay' , "0" ) )

    return sessid , delay


def logout ( config , options , args ) :

    if not options.sessid :
        print "ERROR : Missing parameters"
        parser.print_help()
        sys.exit(1)

    if args :
        parser.print_help()
        sys.exit(1)

    _url = config.get( 'registration' , 'url' )

    if __logout ( _url , options.sessid ) :
        print "session closed : %s" % options.sessid

def __logout ( url , sessid , failed=False ) :

    req = urllib2.Request( "%s/logoff" % url )
    req.add_header( "Cookie" , "pysid=%s" % sessid )
    if failed :
        req.add_header( "X-AmebaStatus" , "FAIL" )

    try :
        res = urllib2.urlopen( req )
    except urllib2.HTTPError , res :
        print "ERROR : %s" % res.msg
        print "".join( res.readlines() )
    else :
        return "".join( res.readlines() )

    return False

def pull ( config , options , args ) :

    if args :
        parser.print_help()
        sys.exit(1)

    _url = config.get( 'registration' , 'url' )
    _uuid = config.get( 'registration' , 'uuid' )

    if not config.has_section( 'pull' ) :
        print "ERROR : pull section mising on configuration"
        sys.exit(1)

    if not config.has_option( 'pull' , 'commands' ) :
        print "ERROR : No commands defined on pull section"
        sys.exit(1)

    _cmds = config.get( 'pull' , 'commands' )

    __pull ( _url , _uuid , _cmds.split(',') )

def __pull ( url , uuid , cmds ) :

    sessid , delay = __login( url , uuid )

    if not sessid : 
        print "ERROR : Login failed"
        return False

    if delay : 
        print "WARNING : sleping %s secs until session gets active" % delay
        time.sleep( delay )

    for cmdline in cmds :
        null = open( "/dev/null" , 'a' )
        command = subprocess.Popen( cmdline.strip().split() , stdout=null , stderr=subprocess.STDOUT )
        null.close()
        command.wait()
        if command.returncode != 0 :
            break
    else :
        return __loginout ( url , uuid )

    print "ERROR : pull failed at %s" % cmdline

    return __logout ( url , sessid , True )


def loginout ( config , options , args ) :

    if args :
        parser.print_help()
        sys.exit(1)

    _url = config.get( 'registration' , 'url' )
    _uuid = config.get( 'registration' , 'uuid' )

    __loginout ( _url , _uuid )

def __loginout ( url , uuid ) :

    sessid , delay = __login( url , uuid )

    if not sessid : 
        print "ERROR : Login failed"
        return False

    return __logout ( url , sessid )


command = { 'register':register ,
            'pull':pull ,
            'logout':logout ,
            'login':login ,
            'loginout':loginout
            }

parser = optparse.OptionParser(usage=usage, version=version)
parser.set_defaults( autouuid=False )

parser.add_option("--autogenerate",
        action="store_true", dest="autouuid",
        help="Automatically generate a random UUID")

parser.add_option("--distro", dest="distro",
        help="Set primary channel")

parser.add_option("--sessid", dest="sessid",
        help="Set session ID")

options , args = parser.parse_args()

if not args :
    parser.print_help()
    sys.exit(1)

subcmd = args.pop(0)

if not command.has_key( subcmd ) :
    parser.print_help()
    sys.exit(1)

command[ subcmd ]( config , options , args )

