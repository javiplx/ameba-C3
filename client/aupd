#!/usr/bin/python

# Copyright (C) 2010 Javier Palacios
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License Version 2
# as published by the Free Software Foundation.
# 
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.


import amebaC3_client.client


import ConfigParser

configfile = "/etc/aupd.conf"

config = ConfigParser.RawConfigParser()
config.read( configfile )

import sys

usage = """
\t%prog [--autogenerate] [--distro distroname] register [url [uuid] ]
\t%prog [--check-interval seconds] [--random-wait seconds] [--check-only|--force-upgrade] [--store] pulldaemon
\t%prog [--check-only|--force-upgrade] [--random-wait seconds] pull
\t%prog login
\t%prog --sessid id logout
\t%prog loginout
"""

version = "%prog 1.1"


import os , glob

def guess_distro ( ) :

    # FIXME : create the first parser with this code !!!
    if os.path.isfile( "/etc/lsb-release" ) :
        fd = open( "/etc/lsb-release" )
        for line in fd.readlines() :
            k,v = line[:-1].split('=',1)
            if k == "DISTRIB_CODENAME" :
                fd.close()
                return v
        fd.close()

    # FIXME : returning distro name is not enough, create specific parsers and return nothing if not implemented
    for file in glob.glob( "/etc/*-release" ) :
        return os.path.basename( file[:-8] )
    # NOTE : en suse hay un /etc/SuSE-brand que es lo que necesitamos

    if os.path.isfile( "/etc/debian_version" ) :
        fd = open( "/etc/debian_version" )
        v = fd.readline()[:-1]
        fd.close()
        return v


#FIXME : Verify user/permissions before writing config, or even calling urlopen
def store_config( config ) :
    fd = open( configfile , 'w' )
    config.write( fd )
    fd.close()


import uuid
import socket

def register ( config , options , args ) :

    options.store = False

    _url = None

    if args :
        _url = args.pop(0)
        options.store = True

    if config.has_option( 'registration' , 'url' ) :
        if _url :
            print "ERROR : server URL already given on configuration file"
            sys.exit(1)
        _url = config.get( 'registration' , 'url' )

    _uuid = None

    if args :
        _uuid = args.pop(0)
        options.store = True

    if _uuid and options.autouuid :
        print "ERROR : You should not give explicit UUID when requesting autogeneration"
        sys.exit(1)

    if options.autouuid :
        _uuid = uuid.uuid4()

    if config.has_option( 'registration' , 'uuid' ) :
        if _uuid :
            print "ERROR : UUID already given on configuration file"
            sys.exit(1)
        _uuid = config.get( 'registration' , 'uuid' )

    if options.distro :
        _distro = options.distro
    else :
        _distro = guess_distro()

    if not _url or not _uuid  or not _distro:
        print "ERROR : Missing parameters"
        parser.print_help()
        sys.exit(1)

    if args :
        print "ERROR : too many arguments"
        parser.print_help()
        sys.exit(1)

    data = { 'UUID':_uuid , 'HOSTNAME':socket.gethostname() , 'DISTRO':_distro }
    if amebaC3_client.client.register( _url , data ) :
        if amebaC3_client.client.has_errmsg() :
            for msg in amebaC3_client.client.get_all_errmsg() :
                print "WARNING : %s" % msg
        if options.store :
            if not config.has_section( 'registration' ) :
                config.add_section( 'registration' )
            config.set( 'registration' , 'url' , _url )
            config.set( 'registration' , 'uuid' , _uuid )
            store_config( config )
    else :
        for msg in amebaC3_client.client.get_all_errmsg() :
            print "ERROR : %s" % msg


def login ( config , options , args ) :

    if args :
        parser.print_help()
        sys.exit(1)

    _url = config.get( 'registration' , 'url' )
    _uuid = config.get( 'registration' , 'uuid' )

    sessid , delay = amebaC3_client.client.login ( _url , _uuid )
    if sessid :
        print "session id : %s" % sessid
        if delay :
            print "activated in %s seconds" % delay
        if amebaC3_client.client.has_errmsg() :
            for msg in amebaC3_client.client.get_all_errmsg() :
                print "WARNING : %s" % msg
    else :
        for msg in amebaC3_client.client.get_all_errmsg() :
            print "ERROR : %s" % msg


def logout ( config , options , args ) :

    if not options.sessid :
        print "ERROR : Missing parameters"
        parser.print_help()
        sys.exit(1)

    if args :
        parser.print_help()
        sys.exit(1)

    _url = config.get( 'registration' , 'url' )

    if amebaC3_client.client.logout ( _url , options.sessid ) :
        print "session closed : %s" % options.sessid
        if amebaC3_client.client.has_errmsg() :
            for msg in amebaC3_client.client.get_all_errmsg() :
                print "WARNING : %s" % msg
    else :
        for msg in amebaC3_client.client.get_all_errmsg() :
            print "ERROR : %s" % msg


import time

def pull ( config , options , args , enable_wait=True ) :

    process_msgs = True
    if args and args[0] == "buffermsgs" :
        args.pop(0)
        process_msgs = False

    if args :
        parser.print_help()
        sys.exit(1)

    _url = config.get( 'registration' , 'url' )
    _uuid = config.get( 'registration' , 'uuid' )

    if not config.has_section( 'pull' ) :
        print "ERROR : pull section mising on configuration"
        sys.exit(1)

    if options.check_only is None :
        if config.has_option( 'pull' , 'check-only' ) :
            options.check_only = config.getboolean( 'pull' , 'check-only' )

    if options.check_only :
        if not config.has_option( 'pull' , 'check_cmds' ) :
            print "ERROR : No check_cmds defined on pull section"
            sys.exit(1)
        _cmds = config.get( 'pull' , 'check_cmds' )
    else :
        if not config.has_option( 'pull' , 'update_cmds' ) :
            print "ERROR : No update_cmds defined on pull section"
            sys.exit(1)
        _cmds = config.get( 'pull' , 'update_cmds' )

    if config.has_option( 'pull' , 'avail_pkgs_ret' ) :
        avail_pkgs_retcode = config.getint( 'pull' , 'avail_pkgs_ret' )
    else :
        avail_pkgs_retcode = 0

    if enable_wait :
        if options.wait :
            random_wait = options.wait
        elif config.has_option( 'pulldaemon' , 'random-wait' ) :
            random_wait = config.getfloat( 'pulldaemon' , 'random-wait' )

        if random_wait :
            time.sleep( random_wait * random.random() )

    ret = amebaC3_client.client.pull ( _url , _uuid , _cmds.split(',') , avail_pkgs_retcode )
    if ret :
        if process_msgs :
            if amebaC3_client.client.has_errmsg() :
                for msg in amebaC3_client.client.get_all_errmsg() :
                    print "WARNING : %s" % msg
    else :
        if process_msgs :
            for msg in amebaC3_client.client.get_all_errmsg() :
                print "ERROR : %s" % msg

    return ret


def loginout ( config , options , args ) :

    if args :
        parser.print_help()
        sys.exit(1)

    _url = config.get( 'registration' , 'url' )
    _uuid = config.get( 'registration' , 'uuid' )

    if amebaC3_client.client.loginout ( _url , _uuid ) :
        if amebaC3_client.client.has_errmsg() :
            for msg in amebaC3_client.client.get_all_errmsg() :
                print "WARNING : %s" % msg
    else :
        for msg in amebaC3_client.client.get_all_errmsg() :
            print "ERROR : %s" % msg


import random

import threading

timerid = None

def __pulldaemon ( config , options , args , check_interval ) :

    ret = pull( config , options , list(args) , False )
    if ret :
        # NOTE : we just drop any warnings
        amebaC3_client.client.get_all_errmsg()
    else :
        # NOTE : error reporting cannot be done via stdout
        amebaC3_client.client.get_all_errmsg()
        #for msg in amebaC3_client.client.get_all_errmsg() :
        #    print "ERROR : %s" % msg

    wait_time = check_interval
    if options.wait :
        wait_time += options.wait * random.random()
    timerid = threading.Timer( wait_time , __pulldaemon , ( config , options , args , check_interval ) )
    timerid.start()

import amebaC3_client.daemon

def pulldaemon ( config , options , args ) :

    if options.interval :
        check_interval = options.interval
    elif config.has_option( 'pulldaemon' , 'check-interval' ) :
        check_interval = config.getfloat( 'pulldaemon' , 'check-interval' )
    else :
        check_interval = False

    if check_interval is False :
        print "ERROR : Missing parameters"
        parser.print_help()
        sys.exit(1)

    if not options.wait and config.has_option( 'pulldaemon' , 'random-wait' ) :
        options.wait = config.getfloat( 'pulldaemon' , 'random-wait' )

    if args :
        parser.print_help()
        sys.exit(1)

    if options.check_only is None :
        if config.has_option( 'pulldaemon' , 'check-only' ) :
            options.check_only = config.getboolean( 'pulldaemon' , 'check-only' )

    if options.store :
        if not config.has_section( 'pulldaemon' ) :
            config.add_section( 'pulldaemon' )
        if options.interval :
            config.set( 'pulldaemon' , 'check-interval' , options.interval )
        if options.wait :
            config.set( 'pulldaemon' , 'random-wait' , options.wait )
        store_config( config )

    amebaC3_client.daemon.REDIRECT_TO = "/tmp/ameba.log"
    open( amebaC3_client.daemon.REDIRECT_TO , "a" ).close()
    retcode = amebaC3_client.daemon.createDaemon()

    args.append( "buffermsgs" )
    # NOTE : we create a timer instead of calling __pulldaemon to delay the initial pull
    wait_time = check_interval
    if options.wait :
        wait_time += options.wait * random.random()
    timerid = threading.Timer( wait_time , __pulldaemon , ( config , options , args , check_interval ) )
    timerid.start()


command = { 'register':register ,
            'pull':pull ,
            'logout':logout ,
            'login':login ,
            'loginout':loginout ,
            'pulldaemon':pulldaemon ,
            }

import optparse

parser = optparse.OptionParser(usage=usage, version=version)
parser.set_defaults( autouuid=False )

parser.add_option("--autogenerate",
        action="store_true", dest="autouuid", default=False,
        help="Automatically generate a random UUID")

parser.add_option("--distro", dest="distro",
        help="Set primary channel")

parser.add_option("--sessid", dest="sessid",
        help="Set session ID")

parser.add_option("--check-only",
        action="store_true", dest="check_only",
        help="Perform only a check for updates")

parser.add_option("--force-upgrade",
        action="store_false", dest="check_only",
        help="Force a system upgrade")

parser.add_option("--check-interval",
	dest="interval", type="float",
        help="Set time interval in seconds within checks")

parser.add_option("--random-wait",
	dest="wait", type="float",
        help="Set maximum random waiting time")

parser.add_option("--store",
        action="store_true", dest="store", default=False,
        help="Store current parameter values into configuration file")

options , args = parser.parse_args()

if not args :
    parser.print_help()
    sys.exit(1)

subcmd = args.pop(0)

if not command.has_key( subcmd ) :
    parser.print_help()
    sys.exit(1)

command[ subcmd ]( config , options , args )

